(defpackage :seasoned-schemer.ch17
  (:use :common-lisp)
  (:import-from :little-schemer.ch01 :atom?)
  (:import-from :little-schemer.ch05 :eqlist?)
  (:import-from :seasoned-schemer.ch16 :find*))
(in-package :seasoned-schemer.ch17)

;; lambda the ultimate object
(defvar counter)
(defvar set-counter)
(defvar consc)
(let ((n 0))
  (setf consc (lambda (x y)
                (setf n (1+ n))
                (cons x y))
        counter (lambda () n)
        set-counter (lambda (x)
                      (setf n x))))

(defun deep (m)
  (if (zerop m)
      'pizza
      (funcall consc (deep (1- m)) ())))

(defparameter deepM
  (let (rs ns)
    (lambda (n)
      (let ((exists (find* n ns rs)))
        (if (not exists)
            (let ((result (if (zerop n)
                              'pizza
                              (funcall consc (funcall deepM (1- n)) ()))))
              (setf rs (cons result rs)
                    ns (cons n ns))
              result)
            exists)))))

(defun supercounter (f)
  (labels ((s (n)
             (if (zerop n)
                 (funcall f n)
                 (progn
                   (funcall f n)
                   (s (1- n))))))
    (s 1000)
    (funcall counter)))

(defun rember1*c (a l)
  (labels ((rm (a l)
             (cond ((null l) (throw 'oh 'no))
                   ((atom? (car l)) (if (eq (car l) a)
                                        (cdr l)
                                        (funcall consc (car l) (rm a (cdr l)))))
                   (t (let ((result (catch 'oh (rm a (car l)))))
                        (if (atom? result)
                            (funcall consc (car l) (rm a (cdr l)))
                            (funcall consc result (cdr l))))))))
    (let ((result (catch 'oh (rm a l))))
      (if (atom? result) l result))))

(defun rember1*c2 (a l)
  (labels ((r (l)
             (cond ((null l) ())
                   ((atom? (car l)) (if (eq (car l) a)
                                        (cdr l)
                                        (funcall consc (car l) (r (cdr l)))))
                   (t (let ((av (r (cdr l))))
                        (if (eqlist? (car l) av)
                            (funcall consc (car l) (r (cdr l)))
                            (funcall consc av (cdr l))))))))
    (r l)))
